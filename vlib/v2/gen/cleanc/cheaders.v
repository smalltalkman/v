// Copyright (c) 2026 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

module cleanc

import v2.ast
import v2.types

const preamble_includes_minimal = r'// Generated by V Clean C Backend
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <dirent.h>
#ifdef __APPLE__
#include <mach/mach_time.h>
#endif
#include <pthread.h>
'

const preamble_includes_full = r'// Generated by V Clean C Backend
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/select.h>
#include <sys/wait.h>
#ifdef __APPLE__
#include <sys/syslimits.h>
#include <mach/mach_time.h>
#include <execinfo.h>
#include <mach-o/dyld.h>
#endif
#include <termios.h>
#include <sys/ioctl.h>
#include <pthread.h>
#include <time.h>
#include <sys/time.h>
#include <sys/statvfs.h>
#include <utime.h>
#include <sys/utsname.h>
#ifdef __APPLE__
#include <sys/ptrace.h>
#include <libproc.h>
#endif
extern char** environ;
#define signal(v_sig, v_handler) signal((v_sig), ((void (*)(int))(v_handler)))
'

fn (mut g Gen) write_preamble() {
	minimal_preamble := g.use_minimal_preamble()
	g.sb.write_string(if minimal_preamble {
		preamble_includes_minimal
	} else {
		preamble_includes_full
	})
	g.sb.writeln('')

	// V primitive type aliases
	g.sb.writeln('// V primitive types')
	g.sb.writeln('typedef int8_t i8;')
	g.sb.writeln('typedef int16_t i16;')
	g.sb.writeln('typedef int32_t i32;')
	g.sb.writeln('typedef int64_t i64;')
	g.sb.writeln('typedef uint8_t u8;')
	g.sb.writeln('typedef uint16_t u16;')
	g.sb.writeln('typedef uint32_t u32;')
	g.sb.writeln('typedef uint64_t u64;')
	g.sb.writeln('typedef float f32;')
	g.sb.writeln('typedef double f64;')
	g.sb.writeln('typedef u8 byte;')
	g.sb.writeln('typedef size_t usize;')
	g.sb.writeln('typedef ptrdiff_t isize;')
	g.sb.writeln('typedef u32 rune;')
	g.sb.writeln('typedef char* byteptr;')
	g.sb.writeln('typedef char* charptr;')
	g.sb.writeln('typedef void* voidptr;')
	g.sb.writeln('typedef void* chan;')
	g.sb.writeln('typedef double float_literal;')
	g.sb.writeln('typedef int64_t int_literal;')
	g.sb.writeln('extern int g_main_argc;')
	g.sb.writeln('extern void* g_main_argv;')
	if minimal_preamble {
		g.sb.writeln('typedef struct sync__RwMutex { pthread_rwlock_t mutex; } sync__RwMutex;')
		g.sb.writeln('static inline void sync__RwMutex_rlock(sync__RwMutex* m) { pthread_rwlock_rdlock(&m->mutex); }')
		g.sb.writeln('static inline void sync__RwMutex_runlock(sync__RwMutex* m) { pthread_rwlock_unlock(&m->mutex); }')
		g.sb.writeln('static inline void sync__RwMutex_lock(sync__RwMutex* m) { pthread_rwlock_wrlock(&m->mutex); }')
		g.sb.writeln('static inline void sync__RwMutex_unlock(sync__RwMutex* m) { pthread_rwlock_unlock(&m->mutex); }')
		g.sb.writeln('')
		return
	}
	// wyhash implementation used by builtin/map and hash modules.
	g.sb.writeln('#ifndef wyhash_final_version_4_2')
	g.sb.writeln('#define wyhash_final_version_4_2')
	g.sb.writeln('#define WYHASH_CONDOM 1')
	g.sb.writeln('#define WYHASH_32BIT_MUM 0')
	g.sb.writeln('#if defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)')
	g.sb.writeln('  #define _likely_(x) __builtin_expect(x,1)')
	g.sb.writeln('  #define _unlikely_(x) __builtin_expect(x,0)')
	g.sb.writeln('#else')
	g.sb.writeln('  #define _likely_(x) (x)')
	g.sb.writeln('  #define _unlikely_(x) (x)')
	g.sb.writeln('#endif')
	g.sb.writeln('static inline uint64_t _wyrot(uint64_t x) { return (x>>32)|(x<<32); }')
	g.sb.writeln('static inline void _wymum(uint64_t *A, uint64_t *B){')
	g.sb.writeln('#if defined(__SIZEOF_INT128__)')
	g.sb.writeln('  __uint128_t r=*A; r*=*B; *A=(uint64_t)r; *B=(uint64_t)(r>>64);')
	g.sb.writeln('#elif defined(_MSC_VER) && defined(_M_X64)')
	g.sb.writeln('  *A=_umul128(*A,*B,B);')
	g.sb.writeln('#else')
	g.sb.writeln('  uint64_t ha=*A>>32, hb=*B>>32, la=(uint32_t)*A, lb=(uint32_t)*B, hi, lo;')
	g.sb.writeln('  uint64_t rh=ha*hb, rm0=ha*lb, rm1=hb*la, rl=la*lb, t=rl+(rm0<<32), c=t<rl;')
	g.sb.writeln('  lo=t+(rm1<<32); c+=lo<t; hi=rh+(rm0>>32)+(rm1>>32)+c;')
	g.sb.writeln('  *A=lo; *B=hi;')
	g.sb.writeln('#endif')
	g.sb.writeln('}')
	g.sb.writeln('static inline uint64_t _wymix(uint64_t A, uint64_t B){ _wymum(&A,&B); return A^B; }')
	g.sb.writeln('#ifndef WYHASH_LITTLE_ENDIAN')
	g.sb.writeln('  #if defined(__LITTLE_ENDIAN__) || defined(__aarch64__) || defined(__x86_64__) || defined(_M_X64) || defined(__i386__) || defined(_M_IX86) || defined(TARGET_ORDER_IS_LITTLE)')
	g.sb.writeln('    #define WYHASH_LITTLE_ENDIAN 1')
	g.sb.writeln('  #else')
	g.sb.writeln('    #define WYHASH_LITTLE_ENDIAN 0')
	g.sb.writeln('  #endif')
	g.sb.writeln('#endif')
	g.sb.writeln('#if (WYHASH_LITTLE_ENDIAN)')
	g.sb.writeln('  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return v;}')
	g.sb.writeln('  static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return v;}')
	g.sb.writeln('#elif defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__clang__)')
	g.sb.writeln('  static inline uint64_t _wyr8(const uint8_t *p) { uint64_t v; memcpy(&v, p, 8); return __builtin_bswap64(v);}')
	g.sb.writeln('  static inline uint64_t _wyr4(const uint8_t *p) { uint32_t v; memcpy(&v, p, 4); return __builtin_bswap32(v);}')
	g.sb.writeln('#else')
	g.sb.writeln('  static inline uint64_t _wyr8(const uint8_t *p) {')
	g.sb.writeln('    uint64_t v; memcpy(&v, p, 8);')
	g.sb.writeln('    return (((v >> 56) & 0xff)| ((v >> 40) & 0xff00)| ((v >> 24) & 0xff0000)| ((v >>  8) & 0xff000000)| ((v <<  8) & 0xff00000000)| ((v << 24) & 0xff0000000000)| ((v << 40) & 0xff000000000000)| ((v << 56) & 0xff00000000000000));')
	g.sb.writeln('  }')
	g.sb.writeln('  static inline uint64_t _wyr4(const uint8_t *p) {')
	g.sb.writeln('    uint32_t v; memcpy(&v, p, 4);')
	g.sb.writeln('    return (((v >> 24) & 0xff)| ((v >>  8) & 0xff00)| ((v <<  8) & 0xff0000)| ((v << 24) & 0xff000000));')
	g.sb.writeln('  }')
	g.sb.writeln('#endif')
	g.sb.writeln('static inline uint64_t _wyr3(const uint8_t *p, size_t k) { return (((uint64_t)p[0])<<16)|(((uint64_t)p[k>>1])<<8)|p[k-1];}')
	g.sb.writeln('static inline uint64_t wyhash(const void *key, size_t len, uint64_t seed, const uint64_t *secret){')
	g.sb.writeln('  const uint8_t *p=(const uint8_t *)key; seed^=_wymix(seed^secret[0],secret[1]); uint64_t a, b;')
	g.sb.writeln('  if(_likely_(len<=16)){')
	g.sb.writeln('    if(_likely_(len>=4)){ a=(_wyr4(p)<<32)|_wyr4(p+((len>>3)<<2)); b=(_wyr4(p+len-4)<<32)|_wyr4(p+len-4-((len>>3)<<2)); }')
	g.sb.writeln('    else if(_likely_(len>0)){ a=_wyr3(p,len); b=0; }')
	g.sb.writeln('    else a=b=0;')
	g.sb.writeln('  } else {')
	g.sb.writeln('    size_t i=len;')
	g.sb.writeln('    if(_unlikely_(i>=48)){')
	g.sb.writeln('      uint64_t see1=seed, see2=seed;')
	g.sb.writeln('      do{')
	g.sb.writeln('        seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed);')
	g.sb.writeln('        see1=_wymix(_wyr8(p+16)^secret[2],_wyr8(p+24)^see1);')
	g.sb.writeln('        see2=_wymix(_wyr8(p+32)^secret[3],_wyr8(p+40)^see2);')
	g.sb.writeln('        p+=48; i-=48;')
	g.sb.writeln('      }while(_likely_(i>=48));')
	g.sb.writeln('      seed^=see1^see2;')
	g.sb.writeln('    }')
	g.sb.writeln('    while(_unlikely_(i>16)){ seed=_wymix(_wyr8(p)^secret[1],_wyr8(p+8)^seed); i-=16; p+=16; }')
	g.sb.writeln('    a=_wyr8(p+i-16); b=_wyr8(p+i-8);')
	g.sb.writeln('  }')
	g.sb.writeln('  a^=secret[1]; b^=seed; _wymum(&a,&b);')
	g.sb.writeln('  return _wymix(a^secret[0]^len,b^secret[1]);')
	g.sb.writeln('}')
	g.sb.writeln('static const uint64_t _wyp[4] = {0x2d358dccaa6c78a5ull, 0x8bb84b93962eacc9ull, 0x4b33a62ed433d4a3ull, 0x4d5a2da51de1aa47ull};')
	g.sb.writeln('static inline uint64_t wyhash64(uint64_t A, uint64_t B){ A^=0x2d358dccaa6c78a5ull; B^=0x8bb84b93962eacc9ull; _wymum(&A,&B); return _wymix(A^0x2d358dccaa6c78a5ull,B^0x8bb84b93962eacc9ull);}')
	g.sb.writeln('#endif')
	g.sb.writeln('#define _MOV')
	g.sb.writeln('typedef u8 termios__Cc;')
	// sync__RwMutex for shared variables
	g.sb.writeln('typedef struct sync__RwMutex { pthread_rwlock_t mutex; } sync__RwMutex;')
	g.sb.writeln('static inline void sync__RwMutex_rlock(sync__RwMutex* m) { pthread_rwlock_rdlock(&m->mutex); }')
	g.sb.writeln('static inline void sync__RwMutex_runlock(sync__RwMutex* m) { pthread_rwlock_unlock(&m->mutex); }')
	g.sb.writeln('static inline void sync__RwMutex_lock(sync__RwMutex* m) { pthread_rwlock_wrlock(&m->mutex); }')
	g.sb.writeln('static inline void sync__RwMutex_unlock(sync__RwMutex* m) { pthread_rwlock_unlock(&m->mutex); }')
	g.sb.writeln('')
	g.sb.writeln('')
}

fn (g &Gen) use_minimal_preamble() bool {
	return g.emit_modules.len == 1 && 'main' in g.emit_modules
}

fn (mut g Gen) emit_runtime_aliases() {
	mut array_names := g.array_aliases.keys()
	array_names.sort()
	// Emit dynamic array aliases (skip fixed arrays)
	for name in array_names {
		if name.starts_with('Array_fixed_') {
			continue
		}
		g.sb.writeln('typedef array ${name};')
	}
	// Emit pointer element typedefs needed by array helper functions.
	// e.g. Array_Coordptr needs 'typedef Coord* Coordptr;'
	// Must come after array aliases so Array_int etc. are defined first.
	for name in array_names {
		if name.starts_with('Array_fixed_') {
			continue
		}
		elem := name['Array_'.len..]
		if elem.len > 3 && elem.ends_with('ptr') {
			base := elem[..elem.len - 3]
			if base !in ['void', 'char', 'byte'] && !elem.starts_with('Array_')
				&& !elem.starts_with('Map_') {
				g.sb.writeln('typedef ${base}* ${elem};')
			}
		}
	}
	// Emit primitive fixed array typedefs (non-primitive ones deferred until after struct defs)
	for name in array_names {
		if !name.starts_with('Array_fixed_') {
			continue
		}
		if info := g.collected_fixed_array_types[name] {
			if info.elem_type in primitive_types
				|| info.elem_type in ['char', 'voidptr', 'charptr', 'byteptr', 'void*', 'char*'] {
				g.sb.writeln('typedef ${info.elem_type} ${name} [${info.size}];')
				alias_key := 'alias_${name}'
				body_key := 'body_${name}'
				g.emitted_types[alias_key] = true
				g.emitted_types[body_key] = true
				// Emit fallback str macros for fixed array types
				g.sb.writeln('#define ${name}_str(a) ((string){.str = "${name}", .len = ${name.len}, .is_lit = 1})')
				g.sb.writeln('#define ${name}__str(a) ${name}_str(a)')
			}
		}
	}
	g.sb.writeln('typedef array VArg_string;')
	g.sb.writeln('bool map_map_eq(map a, map b);')
	mut map_names := g.map_aliases.keys()
	map_names.sort()
	for name in map_names {
		g.sb.writeln('typedef map ${name};')
		// Forward-declare map helper functions (bodies generated later)
		map_str_fn := '${name}_str'
		if map_str_fn !in g.fn_return_types {
			g.sb.writeln('string ${name}_str(${name} m);')
		}
		g.sb.writeln('bool ${name}_map_eq(${name} a, ${name} b);')
	}
	// Option/Result forward declarations (struct definitions emitted later
	// after IError is defined, via emit_option_result_structs)
	mut option_names := g.option_aliases.keys()
	option_names.sort()
	for name in option_names {
		val_type := option_value_type(name)
		if g.option_result_payload_invalid(val_type) {
			continue
		}
		if val_type != '' && val_type != 'void' {
			g.sb.writeln('typedef struct ${name} ${name};')
		} else {
			g.sb.writeln('typedef _option ${name};')
		}
	}
	mut result_names := g.result_aliases.keys()
	result_names.sort()
	for name in result_names {
		val_type := g.result_value_type(name)
		if g.option_result_payload_invalid(val_type) {
			continue
		}
		if val_type != '' && val_type != 'void' {
			g.sb.writeln('typedef struct ${name} ${name};')
		} else {
			g.sb.writeln('typedef _result ${name};')
		}
	}
}

fn (mut g Gen) get_enum_name(node ast.EnumDecl) string {
	if g.cur_module != '' && g.cur_module != 'main' && g.cur_module != 'builtin' {
		return '${g.cur_module}__${node.name}'
	}
	return node.name
}

fn (mut g Gen) gen_enum_decl(node ast.EnumDecl) {
	name := g.get_enum_name(node)
	enum_key := 'enum_${name}'
	if enum_key in g.emitted_types {
		return
	}
	g.emitted_types[enum_key] = true
	mut is_flag := false
	for attribute in node.attributes {
		if attribute.name == 'flag' {
			is_flag = true
			break
		}
		if attribute.name == '' && attribute.value is ast.Ident && attribute.value.name == 'flag' {
			is_flag = true
			break
		}
	}

	g.sb.writeln('typedef enum {')
	for i, field in node.fields {
		g.sb.write_string('\t${name}__${field.name}')
		if field.value !is ast.EmptyExpr {
			g.sb.write_string(' = ')
			g.expr(field.value)
		} else if is_flag {
			g.sb.write_string(' = ${u64(1) << i}U')
		}
		if i < node.fields.len - 1 {
			g.sb.writeln(',')
		} else {
			g.sb.writeln('')
		}
	}
	g.sb.writeln('} ${name};')
	g.sb.writeln('')
	enum_str_fn := '${name}__str'
	if enum_str_fn !in g.fn_return_types {
		g.sb.writeln('#define ${name}__str(v) int__str((int)(v))')
	}
	enum_short_str_fn := '${name}_str'
	if enum_short_str_fn !in g.fn_return_types {
		g.sb.writeln('#define ${name}_str(v) ${name}__str(v)')
	}
	g.sb.writeln('')
}

// emit_map_str_functions generates Map_K_V_str functions for all map types.
fn (mut g Gen) emit_map_str_functions() {
	mut map_names := g.map_aliases.keys()
	map_names.sort()
	for name in map_names {
		// Skip if the user already defined this function
		if '${name}_str' in g.fn_return_types {
			continue
		}
		// Parse key and value types from Map_K_V name
		without_prefix := name.all_after('Map_')
		key_type, value_type := g.parse_map_kv_types(without_prefix)
		if key_type == '' || value_type == '' {
			continue
		}
		// Skip generic placeholder types (single uppercase letters like K, V, T)
		if key_type.len == 1 && key_type[0] >= `A` && key_type[0] <= `Z` {
			continue
		}
		// Skip types that can't be safely used as local variables (fixed arrays, etc.)
		if !g.can_emit_map_str_for_type(key_type) || !g.can_emit_map_str_for_type(value_type) {
			// Emit a fallback that returns the type name
			g.sb.writeln('')
			g.sb.writeln('string ${name}_str(${name} m) {')
			g.sb.writeln('\treturn (string){.str = "${name}", .len = ${name.len}, .is_lit = 1};')
			g.sb.writeln('}')
			continue
		}
		g.sb.writeln('')
		g.sb.writeln('string ${name}_str(${name} m) {')
		g.sb.writeln('\tstrings__Builder sb = strings__new_builder(2 + m.key_values.len * 10);')
		g.sb.writeln('\tstrings__Builder__write_string(&sb, (string){.str = "{", .len = 1, .is_lit = 1});')
		g.sb.writeln('\tbool is_first = true;')
		g.sb.writeln('\tfor (int i = 0; i < m.key_values.len; ++i) {')
		g.sb.writeln('\t\tif (!DenseArray__has_index(&m.key_values, i)) continue;')
		g.sb.writeln('\t\tif (!is_first) strings__Builder__write_string(&sb, (string){.str = ", ", .len = 2, .is_lit = 1});')
		// Key
		g.sb.writeln('\t\t${key_type} key = *(${key_type}*)DenseArray__key(&m.key_values, i);')
		g.emit_map_str_write_val('key', key_type)
		// Separator
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, (string){.str = ": ", .len = 2, .is_lit = 1});')
		// Value
		if value_type.starts_with('Array_fixed_') {
			// Fixed arrays can't be assigned to local variables; use pointer
			elem_type, arr_len := g.parse_fixed_array_type(value_type)
			g.sb.writeln('\t\t${elem_type}* val_ptr = (${elem_type}*)DenseArray__value(&m.key_values, i);')
			g.emit_fixed_array_str_write('val_ptr', elem_type, arr_len)
		} else {
			g.sb.writeln('\t\t${value_type} val = *(${value_type}*)DenseArray__value(&m.key_values, i);')
			g.emit_map_str_write_val('val', value_type)
		}
		g.sb.writeln('\t\tis_first = false;')
		g.sb.writeln('\t}')
		g.sb.writeln('\tstrings__Builder__write_string(&sb, (string){.str = "}", .len = 1, .is_lit = 1});')
		g.sb.writeln('\treturn strings__Builder__str(&sb);')
		g.sb.writeln('}')
	}
}

fn (g &Gen) can_emit_map_str_for_type(type_name string) bool {
	// Primitive types are always OK
	if type_name in ['string', 'int', 'i8', 'i16', 'i32', 'i64', 'u8', 'u16', 'u32', 'u64', 'f32',
		'f64', 'bool', 'rune', 'voidptr'] {
		return true
	}
	// Fixed arrays — need special handling but can be emitted
	if type_name.starts_with('Array_fixed_') {
		return true
	}
	// Pointer-like types that may not be valid C type names
	if type_name in ['intptr', 'charptr', 'byteptr'] || type_name.ends_with('ptr') {
		return false
	}
	// Check if a str function exists for this type
	if '${type_name}_str' in g.fn_return_types || '${type_name}__str' in g.fn_return_types {
		return true
	}
	// Map types can call their own str function (recursive)
	if type_name.starts_with('Map_') {
		return true
	}
	// Array types — check if Array_T_str exists
	if type_name.starts_with('Array_') {
		return '${type_name}_str' in g.fn_return_types
	}
	// For other types (structs, enums, etc.), check if str function exists
	return '${type_name}_str' in g.fn_return_types || '${type_name}__str' in g.fn_return_types
}

fn (mut g Gen) emit_map_str_write_val(var_name string, type_name string) {
	if type_name == 'string' {
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, (string){.str = "\'", .len = 1, .is_lit = 1});')
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, ${var_name});')
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, (string){.str = "\'", .len = 1, .is_lit = 1});')
	} else if type_name == 'rune' {
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, (string){.str = "`", .len = 1, .is_lit = 1});')
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, rune__str(${var_name}));')
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, (string){.str = "`", .len = 1, .is_lit = 1});')
	} else if type_name in ['int', 'i8', 'i16', 'i32', 'i64'] {
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, int__str((int)(${var_name})));')
	} else if type_name in ['u8', 'u16', 'u32', 'u64'] {
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, u64__str((u64)(${var_name})));')
	} else if type_name == 'f32' {
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, f32__str(${var_name}));')
	} else if type_name == 'f64' {
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, f64__str(${var_name}));')
	} else if type_name == 'bool' {
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, ${var_name} ? (string){.str = "true", .len = 4, .is_lit = 1} : (string){.str = "false", .len = 5, .is_lit = 1});')
	} else if type_name == 'voidptr' {
		// Print pointer as hex
		g.sb.writeln('\t\t{ char _buf[20]; snprintf(_buf, sizeof(_buf), "%p", ${var_name}); strings__Builder__write_string(&sb, (string){.str = _buf, .len = strlen(_buf), .is_lit = 0}); }')
	} else {
		// For any other type, try Type_str. If the function doesn't exist,
		// this will cause a C error — but it's the caller's responsibility
		// to ensure str functions exist for custom types used as map keys/values.
		g.sb.writeln('\t\tstrings__Builder__write_string(&sb, ${type_name}_str(${var_name}));')
	}
}

// parse_fixed_array_type parses "Array_fixed_f64_2" into ("f64", 2).
fn (g &Gen) parse_fixed_array_type(type_name string) (string, int) {
	// Format: Array_fixed_<elem_type>_<len>
	without_prefix := type_name.all_after('Array_fixed_')
	// The last _N is the length
	last_underscore := without_prefix.last_index('_') or { return '', 0 }
	elem_type := without_prefix[..last_underscore]
	arr_len := without_prefix[last_underscore + 1..].int()
	return elem_type, arr_len
}

// emit_fixed_array_str_write generates code to format a fixed array as "[e1, e2, ...]".
fn (mut g Gen) emit_fixed_array_str_write(ptr_var string, elem_type string, arr_len int) {
	g.sb.writeln('\t\tstrings__Builder__write_string(&sb, (string){.str = "[", .len = 1, .is_lit = 1});')
	for j in 0 .. arr_len {
		if j > 0 {
			g.sb.writeln('\t\tstrings__Builder__write_string(&sb, (string){.str = ", ", .len = 2, .is_lit = 1});')
		}
		g.emit_map_str_write_val('${ptr_var}[${j}]', elem_type)
	}
	g.sb.writeln('\t\tstrings__Builder__write_string(&sb, (string){.str = "]", .len = 1, .is_lit = 1});')
}

// emit_map_eq_functions generates Map_K_V_map_eq functions for all map types.
fn (mut g Gen) emit_map_eq_functions() {
	// Generic fallback for when the specific map type is not known
	g.sb.writeln('')
	g.sb.writeln('bool map_map_eq(map a, map b) {')
	g.sb.writeln('\tif (a.len != b.len) return false;')
	g.sb.writeln('\tfor (int i = 0; i < a.key_values.len; ++i) {')
	g.sb.writeln('\t\tif (!DenseArray__has_index(&a.key_values, i)) continue;')
	g.sb.writeln('\t\tvoid* k = DenseArray__key(&a.key_values, i);')
	g.sb.writeln('\t\tif (!map__exists(&b, k)) return false;')
	g.sb.writeln('\t\tvoid* va = DenseArray__value(&a.key_values, i);')
	g.sb.writeln('\t\tvoid* vb_p = map__get(&b, k, va);')
	g.sb.writeln('\t\tif (memcmp(va, vb_p, a.value_bytes) != 0) return false;')
	g.sb.writeln('\t}')
	g.sb.writeln('\treturn true;')
	g.sb.writeln('}')

	mut map_names := g.map_aliases.keys()
	map_names.sort()
	for name in map_names {
		without_prefix := name.all_after('Map_')
		key_type, value_type := g.parse_map_kv_types(without_prefix)
		if key_type == '' || value_type == '' {
			g.sb.writeln('')
			g.sb.writeln('bool ${name}_map_eq(${name} a, ${name} b) { return map_map_eq(a, b); }')
			continue
		}
		// Skip generic placeholder types
		if value_type.len == 1 && value_type[0] >= `A` && value_type[0] <= `Z` {
			g.sb.writeln('')
			g.sb.writeln('bool ${name}_map_eq(${name} a, ${name} b) { return map_map_eq(a, b); }')
			continue
		}
		g.sb.writeln('')
		g.sb.writeln('bool ${name}_map_eq(${name} a, ${name} b) {')
		g.sb.writeln('\tif (a.len != b.len) return false;')
		g.sb.writeln('\tfor (int i = 0; i < a.key_values.len; ++i) {')
		g.sb.writeln('\t\tif (!DenseArray__has_index(&a.key_values, i)) continue;')
		g.sb.writeln('\t\tvoid* k = DenseArray__key(&a.key_values, i);')
		g.sb.writeln('\t\tif (!map__exists(&b, k)) return false;')
		// Compare values based on value type
		if value_type == 'string' {
			g.sb.writeln('\t\tstring va = *(string*)map__get(&a, k, &(string){0});')
			g.sb.writeln('\t\tstring vb = *(string*)map__get(&b, k, &(string){0});')
			g.sb.writeln('\t\tif (!string__eq(va, vb)) return false;')
		} else if value_type in ['int', 'i8', 'i16', 'i32', 'i64', 'u8', 'u16', 'u32', 'u64', 'f32',
			'f64', 'bool', 'rune', 'voidptr'] {
			g.sb.writeln('\t\t${value_type} va = *(${value_type}*)map__get(&a, k, &(${value_type}){0});')
			g.sb.writeln('\t\t${value_type} vb = *(${value_type}*)map__get(&b, k, &(${value_type}){0});')
			g.sb.writeln('\t\tif (va != vb) return false;')
		} else if value_type in ['intptr', 'u8ptr', 'charptr', 'byteptr']
			|| value_type.ends_with('ptr') {
			// Pointer-like types (V aliases and module-qualified pointer types): compare as void*
			g.sb.writeln('\t\tvoid* va = *(void**)map__get(&a, k, &(void*){0});')
			g.sb.writeln('\t\tvoid* vb = *(void**)map__get(&b, k, &(void*){0});')
			g.sb.writeln('\t\tif (va != vb) return false;')
		} else if value_type.starts_with('Array_fixed_') {
			// Fixed arrays: use memcmp (they are plain C arrays)
			g.sb.writeln('\t\tvoid* va = map__get(&a, k, &(${value_type}){0});')
			g.sb.writeln('\t\tvoid* vb = map__get(&b, k, &(${value_type}){0});')
			g.sb.writeln('\t\tif (memcmp(va, vb, sizeof(${value_type})) != 0) return false;')
		} else if value_type == 'array' || value_type.starts_with('Array_') {
			// Array values: use __v2_array_eq for deep comparison
			g.sb.writeln('\t\tarray va = *(array*)map__get(&a, k, &(${value_type}){0});')
			g.sb.writeln('\t\tarray vb = *(array*)map__get(&b, k, &(${value_type}){0});')
			g.sb.writeln('\t\tif (!__v2_array_eq(va, vb)) return false;')
		} else if value_type.starts_with('Map_') {
			// Map values: use the map's own eq function for deep comparison
			g.sb.writeln('\t\t${value_type} va = *(${value_type}*)map__get(&a, k, &(${value_type}){0});')
			g.sb.writeln('\t\t${value_type} vb = *(${value_type}*)map__get(&b, k, &(${value_type}){0});')
			g.sb.writeln('\t\tif (!${value_type}_map_eq(va, vb)) return false;')
		} else {
			// Try to look up struct fields for deep comparison
			struct_type := g.lookup_struct_type_by_c_name(value_type)
			if struct_type.fields.len > 0 {
				g.sb.writeln('\t\t${value_type} va = *(${value_type}*)map__get(&a, k, &(${value_type}){0});')
				g.sb.writeln('\t\t${value_type} vb = *(${value_type}*)map__get(&b, k, &(${value_type}){0});')
				g.emit_struct_field_eq(struct_type, 'va', 'vb')
			} else {
				// Fallback: use memcmp on the value
				g.sb.writeln('\t\tvoid* va = map__get(&a, k, &(${value_type}){0});')
				g.sb.writeln('\t\tvoid* vb = map__get(&b, k, &(${value_type}){0});')
				g.sb.writeln('\t\tif (memcmp(va, vb, sizeof(${value_type})) != 0) return false;')
			}
		}
		g.sb.writeln('\t}')
		g.sb.writeln('\treturn true;')
		g.sb.writeln('}')
	}
}

// lookup_struct_type_by_c_name resolves a C type name to a types.Struct by searching
// all known module scopes. C names may be like "MValue" (current module) or "os__File".
// Returns empty Struct for sum types/aliases (their merged fields aren't safe for field access).
fn (mut g Gen) lookup_struct_type_by_c_name(c_name string) types.Struct {
	if g.env == unsafe { nil } {
		return types.Struct{}
	}
	// Try extracting module from mangled name (e.g. "os__File" -> module "os", name "File")
	mut mod_name := ''
	mut struct_name := c_name
	if idx := c_name.index('__') {
		mod_name = c_name[..idx]
		struct_name = c_name[idx + 2..]
	}
	if mod_name != '' {
		if mut scope := g.env_scope(mod_name) {
			if obj := scope.lookup_parent(struct_name, 0) {
				typ := obj.typ()
				// Skip sum types - their merged fields aren't safe for direct access
				if typ is types.Alias || typ is types.SumType {
					return types.Struct{}
				}
				if typ is types.Struct {
					return typ
				}
			}
		}
	}
	// Try current module, main, and builtin scopes
	mut tried := map[string]bool{}
	cur_mod := if g.cur_module != '' { g.cur_module } else { 'main' }
	for try_mod in [cur_mod, 'main', 'builtin'] {
		if tried[try_mod] {
			continue
		}
		tried[try_mod] = true
		if mut scope := g.env_scope(try_mod) {
			if obj := scope.lookup_parent(struct_name, 0) {
				typ := obj.typ()
				if typ is types.Alias {
					return types.Struct{}
				}
				if typ is types.Struct {
					return typ
				}
			}
		}
	}
	// Try all module scopes from files
	for file in g.files {
		file_mod := file.mod
		if tried[file_mod] {
			continue
		}
		tried[file_mod] = true
		if mut scope := g.env_scope(file_mod) {
			if obj := scope.lookup_parent(struct_name, 0) {
				typ := obj.typ()
				if typ is types.Alias {
					return types.Struct{}
				}
				if typ is types.Struct {
					return typ
				}
			}
		}
	}
	return types.Struct{}
}

// emit_struct_field_eq generates field-by-field comparison code for a struct type.
fn (mut g Gen) emit_struct_field_eq(s types.Struct, va string, vb string) {
	for field in s.fields {
		fname := field.name
		ftype := field.typ
		match ftype {
			types.String {
				g.sb.writeln('\t\tif (!string__eq(${va}.${fname}, ${vb}.${fname})) return false;')
			}
			types.Map {
				c_type := g.types_type_to_c(ftype)
				if c_type.starts_with('Map_') {
					g.sb.writeln('\t\tif (!${c_type}_map_eq(${va}.${fname}, ${vb}.${fname})) return false;')
				} else {
					g.sb.writeln('\t\tif (!map_map_eq(${va}.${fname}, ${vb}.${fname})) return false;')
				}
			}
			types.Array {
				g.sb.writeln('\t\tif (!__v2_array_eq(${va}.${fname}, ${vb}.${fname})) return false;')
			}
			types.Primitive {
				g.sb.writeln('\t\tif (${va}.${fname} != ${vb}.${fname}) return false;')
			}
			types.Pointer {
				g.sb.writeln('\t\tif (${va}.${fname} != ${vb}.${fname}) return false;')
			}
			types.Rune {
				g.sb.writeln('\t\tif (${va}.${fname} != ${vb}.${fname}) return false;')
			}
			types.Enum {
				g.sb.writeln('\t\tif (${va}.${fname} != ${vb}.${fname}) return false;')
			}
			types.Struct {
				// Nested struct: use memcmp as fallback
				c_type := g.types_type_to_c(ftype)
				g.sb.writeln('\t\tif (memcmp(&${va}.${fname}, &${vb}.${fname}, sizeof(${c_type})) != 0) return false;')
			}
			else {
				c_type := g.types_type_to_c(ftype)
				g.sb.writeln('\t\tif (memcmp(&${va}.${fname}, &${vb}.${fname}, sizeof(${c_type})) != 0) return false;')
			}
		}
	}
}

// parse_map_kv_types parses key and value types from a "key_value" string.
fn (g &Gen) parse_map_kv_types(kv_str string) (string, string) {
	// Try simple primitive types first (they're unambiguous since they don't
	// contain underscores — except for the separator underscore)
	simple_types := ['string', 'int', 'i8', 'i16', 'i32', 'i64', 'u8', 'u16', 'u32', 'u64', 'f32',
		'f64', 'bool', 'rune', 'voidptr', 'charptr', 'byteptr']
	for st in simple_types {
		if kv_str.starts_with('${st}_') {
			return st, kv_str.all_after('${st}_')
		}
	}
	// For compound key types: try each underscore position and check if the
	// key type is a known type alias/struct
	for i := 1; i < kv_str.len; i++ {
		if kv_str[i] == `_` {
			key := kv_str[..i]
			value := kv_str[i + 1..]
			if value == '' {
				continue
			}
			// Verify key is a known type
			if 'Map_${key}_' in g.map_aliases.keys().map(it + '_') || key in g.array_aliases
				|| key in g.emitted_types || key in simple_types {
				return key, value
			}
		}
	}
	// Last resort: split on last underscore
	last_idx := kv_str.last_index('_') or { return '', '' }
	if last_idx > 0 && last_idx < kv_str.len - 1 {
		return kv_str[..last_idx], kv_str[last_idx + 1..]
	}
	return '', ''
}
